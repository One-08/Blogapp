{"version":3,"file":"mat-contenteditable.directive.d.ts","sources":["mat-contenteditable.directive.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA","sourcesContent":["import { ElementRef, Renderer2, DoCheck } from '@angular/core';\nimport { MatFormFieldControl } from '@angular/material/form-field';\nimport { ControlValueAccessor, FormGroupDirective, NgControl, NgForm } from '@angular/forms';\nimport { ErrorStateMatcher, CanUpdateErrorStateCtor, CanUpdateErrorState } from '@angular/material/core';\nimport { Subject } from 'rxjs';\n/** @docs-private */\ndeclare class MatInputBase {\n    _defaultErrorStateMatcher: ErrorStateMatcher;\n    _parentForm: NgForm;\n    _parentFormGroup: FormGroupDirective;\n    /** @docs-private */\n    ngControl: NgControl;\n    constructor(_defaultErrorStateMatcher: ErrorStateMatcher, _parentForm: NgForm, _parentFormGroup: FormGroupDirective, \n    /** @docs-private */\n    ngControl: NgControl);\n}\nexport declare const _MatInputMixinBase: CanUpdateErrorStateCtor & typeof MatInputBase;\nexport declare class MatContenteditableDirective extends _MatInputMixinBase implements ControlValueAccessor, MatFormFieldControl<string>, DoCheck, CanUpdateErrorState {\n    private elementRef;\n    private renderer;\n    ngControl: NgControl;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * See https://material.angular.io/guide/creating-a-custom-form-field-control\n     */\n    static nextId: number;\n    value: string;\n    readonly stateChanges: Subject<void>;\n    id: string;\n    placeholder: string;\n    private _placeholder;\n    focused: boolean;\n    contentEmpty: Array<string>;\n    readonly empty: boolean;\n    readonly shouldLabelFloat: boolean;\n    required: boolean;\n    private _required;\n    disabled: boolean;\n    private _disabled;\n    errorState: boolean;\n    errorStateMatcher: ErrorStateMatcher;\n    controlType: string;\n    describedBy: string;\n    private onChange;\n    private onTouched;\n    private removeDisabledState;\n    propValueAccessor: string;\n    constructor(elementRef: ElementRef, renderer: Renderer2, ngControl: NgControl, _parentForm: NgForm, _parentFormGroup: FormGroupDirective, _defaultErrorStateMatcher: ErrorStateMatcher);\n    ngDoCheck(): void;\n    callOnChange(): void;\n    callOnFocused(): void;\n    callOnTouched(): void;\n    setDescribedByIds(ids: string[]): void;\n    onContainerClick(): void;\n    /**\n     * Writes a new value to the element.\n     * This method will be called by the forms API to write\n     * to the view when programmatic (model -> view) changes are requested.\n     *\n     * See: [ControlValueAccessor](https://angular.io/api/forms/ControlValueAccessor#members)\n     */\n    writeValue(value: any): void;\n    /**\n     * Registers a callback function that should be called when\n     * the control's value changes in the UI.\n     *\n     * This is called by the forms API on initialization so it can update\n     * the form model when values propagate from the view (view -> model).\n     */\n    registerOnChange(fn: () => void): void;\n    /**\n     * Registers a callback function that should be called when the control receives a blur event.\n     * This is called by the forms API on initialization so it can update the form model on blur.\n     */\n    registerOnTouched(fn: () => void): void;\n    /**\n     * This function is called by the forms API when the control status changes to or from \"DISABLED\".\n     * Depending on the value, it should enable or disable the appropriate DOM element.\n     */\n    setDisabledState(isDisabled: boolean): void;\n    private listenerDisabledState;\n}\nexport {};\n"]}