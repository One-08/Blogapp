import { ElementRef, Renderer2, DoCheck } from '@angular/core';
import { MatFormFieldControl } from '@angular/material/form-field';
import { ControlValueAccessor, FormGroupDirective, NgControl, NgForm } from '@angular/forms';
import { ErrorStateMatcher, CanUpdateErrorStateCtor, CanUpdateErrorState } from '@angular/material/core';
import { Subject } from 'rxjs';
/** @docs-private */
import * as ɵngcc0 from '@angular/core';
declare class MatInputBase {
    _defaultErrorStateMatcher: ErrorStateMatcher;
    _parentForm: NgForm;
    _parentFormGroup: FormGroupDirective;
    /** @docs-private */
    ngControl: NgControl;
    constructor(_defaultErrorStateMatcher: ErrorStateMatcher, _parentForm: NgForm, _parentFormGroup: FormGroupDirective, 
    /** @docs-private */
    ngControl: NgControl);
}
export declare const _MatInputMixinBase: CanUpdateErrorStateCtor & typeof MatInputBase;
export declare class MatContenteditableDirective extends _MatInputMixinBase implements ControlValueAccessor, MatFormFieldControl<string>, DoCheck, CanUpdateErrorState {
    private elementRef;
    private renderer;
    ngControl: NgControl;
    /**
     * Implemented as part of MatFormFieldControl.
     * See https://material.angular.io/guide/creating-a-custom-form-field-control
     */
    static nextId: number;
    value: string;
    readonly stateChanges: Subject<void>;
    id: string;
    placeholder: string;
    private _placeholder;
    focused: boolean;
    contentEmpty: Array<string>;
    readonly empty: boolean;
    readonly shouldLabelFloat: boolean;
    required: boolean;
    private _required;
    disabled: boolean;
    private _disabled;
    errorState: boolean;
    errorStateMatcher: ErrorStateMatcher;
    controlType: string;
    describedBy: string;
    private onChange;
    private onTouched;
    private removeDisabledState;
    propValueAccessor: string;
    constructor(elementRef: ElementRef, renderer: Renderer2, ngControl: NgControl, _parentForm: NgForm, _parentFormGroup: FormGroupDirective, _defaultErrorStateMatcher: ErrorStateMatcher);
    ngDoCheck(): void;
    callOnChange(): void;
    callOnFocused(): void;
    callOnTouched(): void;
    setDescribedByIds(ids: string[]): void;
    onContainerClick(): void;
    /**
     * Writes a new value to the element.
     * This method will be called by the forms API to write
     * to the view when programmatic (model -> view) changes are requested.
     *
     * See: [ControlValueAccessor](https://angular.io/api/forms/ControlValueAccessor#members)
     */
    writeValue(value: any): void;
    /**
     * Registers a callback function that should be called when
     * the control's value changes in the UI.
     *
     * This is called by the forms API on initialization so it can update
     * the form model when values propagate from the view (view -> model).
     */
    registerOnChange(fn: () => void): void;
    /**
     * Registers a callback function that should be called when the control receives a blur event.
     * This is called by the forms API on initialization so it can update the form model on blur.
     */
    registerOnTouched(fn: () => void): void;
    /**
     * This function is called by the forms API when the control status changes to or from "DISABLED".
     * Depending on the value, it should enable or disable the appropriate DOM element.
     */
    setDisabledState(isDisabled: boolean): void;
    private listenerDisabledState;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<MatContenteditableDirective, [null, null, { optional: true; self: true; }, { optional: true; }, { optional: true; }, null]>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<MatContenteditableDirective, "[contenteditable]", never, { "contentEmpty": "contentEmpty"; "propValueAccessor": "propValueAccessor"; "value": "value"; "placeholder": "placeholder"; "required": "required"; "disabled": "disabled"; "errorStateMatcher": "errorStateMatcher"; }, {}, never>;
}
export {};

//# sourceMappingURL=mat-contenteditable.directive.d.ts.map